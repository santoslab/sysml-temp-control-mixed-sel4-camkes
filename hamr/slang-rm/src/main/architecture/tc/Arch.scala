// #Sireum

package tc

import org.sireum._
import art._
import art.PortMode._
import art.DispatchPropertyProtocol._
import art.Art.BridgeId._
import art.Art.PortId._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

object Arch {
  val TempControlSystem_Instance_tsp_tst : tc.TempControlMixedSeL4CAmKES.TempSensor_tsp_tst_Bridge = {
    val currentTemp = Port[TempControlMixedSeL4CAmKES.Temperature] (id = portId"0", name = "TempControlSystem_Instance_tsp_tst_currentTemp", mode = DataOut)
    val tempChanged = Port[art.Empty] (id = portId"1", name = "TempControlSystem_Instance_tsp_tst_tempChanged", mode = EventOut)

    tc.TempControlMixedSeL4CAmKES.TempSensor_tsp_tst_Bridge(
      id = bridgeId"0",
      name = "TempControlSystem_Instance_tsp_tst",
      dispatchProtocol = Periodic(period = 1000),
      dispatchTriggers = None(),

      currentTemp = currentTemp,
      tempChanged = tempChanged
    )
  }
  val TempControlSystem_Instance_tcp_tct : tc.TempControlMixedSeL4CAmKES.TempControl_tcp_tct_Bridge = {
    val currentTemp = Port[TempControlMixedSeL4CAmKES.Temperature] (id = portId"2", name = "TempControlSystem_Instance_tcp_tct_currentTemp", mode = DataIn)
    val tempChanged = Port[art.Empty] (id = portId"3", name = "TempControlSystem_Instance_tcp_tct_tempChanged", mode = EventIn)
    val fanAck = Port[TempControlMixedSeL4CAmKES.FanAck.Type] (id = portId"4", name = "TempControlSystem_Instance_tcp_tct_fanAck", mode = EventIn)
    val setPoint = Port[TempControlMixedSeL4CAmKES.SetPoint] (id = portId"5", name = "TempControlSystem_Instance_tcp_tct_setPoint", mode = EventIn)
    val fanCmd = Port[TempControlMixedSeL4CAmKES.FanCmd.Type] (id = portId"6", name = "TempControlSystem_Instance_tcp_tct_fanCmd", mode = EventOut)

    tc.TempControlMixedSeL4CAmKES.TempControl_tcp_tct_Bridge(
      id = bridgeId"1",
      name = "TempControlSystem_Instance_tcp_tct",
      dispatchProtocol = Sporadic(min = 1000),
      dispatchTriggers = None(),

      currentTemp = currentTemp,
      tempChanged = tempChanged,
      fanAck = fanAck,
      setPoint = setPoint,
      fanCmd = fanCmd
    )
  }
  val TempControlSystem_Instance_fp_ft : tc.TempControlMixedSeL4CAmKES.Fan_fp_ft_Bridge = {
    val fanCmd = Port[TempControlMixedSeL4CAmKES.FanCmd.Type] (id = portId"7", name = "TempControlSystem_Instance_fp_ft_fanCmd", mode = EventIn)
    val fanAck = Port[TempControlMixedSeL4CAmKES.FanAck.Type] (id = portId"8", name = "TempControlSystem_Instance_fp_ft_fanAck", mode = EventOut)

    tc.TempControlMixedSeL4CAmKES.Fan_fp_ft_Bridge(
      id = bridgeId"2",
      name = "TempControlSystem_Instance_fp_ft",
      dispatchProtocol = Sporadic(min = 1),
      dispatchTriggers = None(),

      fanCmd = fanCmd,
      fanAck = fanAck
    )
  }

  val ad : ArchitectureDescription = {

    ArchitectureDescription(
      components = IS[Art.BridgeId, Bridge] (TempControlSystem_Instance_tsp_tst, TempControlSystem_Instance_tcp_tct, TempControlSystem_Instance_fp_ft),

      connections = IS[Art.ConnectionId, UConnection] (Connection(from = TempControlSystem_Instance_tsp_tst.currentTemp, to = TempControlSystem_Instance_tcp_tct.currentTemp),
                                                       Connection(from = TempControlSystem_Instance_tsp_tst.tempChanged, to = TempControlSystem_Instance_tcp_tct.tempChanged),
                                                       Connection(from = TempControlSystem_Instance_tcp_tct.fanCmd, to = TempControlSystem_Instance_fp_ft.fanCmd),
                                                       Connection(from = TempControlSystem_Instance_fp_ft.fanAck, to = TempControlSystem_Instance_tcp_tct.fanAck))
    )
  }
}
