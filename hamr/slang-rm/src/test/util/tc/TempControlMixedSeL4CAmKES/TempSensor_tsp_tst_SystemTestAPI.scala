// #Sireum

package tc.TempControlMixedSeL4CAmKES

import org.sireum._
import art._
import tc.SystemTestSuiteSlang.runtimeMonitorStream
import tc._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

object TempSensor_tsp_tst_SystemTestAPI {
  /** helper method to set the values of all incoming ports
    */
  def put_concrete_inputs(): Unit = {
  }



  def fetchContainer(): tc.TempControlMixedSeL4CAmKES.TempSensor_tsp_tst_PostState_Container_PS = {
    if (runtimeMonitorStream.contains(Arch.TempControlSystem_Instance_tsp_tst.id)) {
      val (_, postContainer_) = runtimeMonitorStream.get(Arch.TempControlSystem_Instance_tsp_tst.id).get
      return postContainer_.asInstanceOf[tc.TempControlMixedSeL4CAmKES.TempSensor_tsp_tst_PostState_Container_PS]
    }
    else {
      assert(F, s"No post state recorded for ${Arch.TempControlSystem_Instance_tsp_tst.name}")
      halt(s"No post state recorded for ${Arch.TempControlSystem_Instance_tsp_tst.name}")
    }
  }

  def check_concrete_outputs(api_tempChanged: Option[art.Empty],
                             api_currentTemp: TempControlMixedSeL4CAmKES.Temperature): Unit = {
    var failureReasons: ISZ[ST] = ISZ()

    val actual_tempChanged = get_api_tempChanged()
    if (api_tempChanged != actual_tempChanged) {
      failureReasons = failureReasons :+ st"'tempChanged' did not match expected.  Expected: $api_tempChanged, Actual: $actual_tempChanged"
    }
    val actual_currentTemp = get_api_currentTemp()
    if (api_currentTemp != actual_currentTemp) {
      failureReasons = failureReasons :+ st"'currentTemp' did not match expected.  Expected: $api_currentTemp, Actual: $actual_currentTemp"
    }

    assert(failureReasons.isEmpty, st"${(failureReasons, "\n")}".render)
  }

  def get_api_tempChanged(): Option[art.Empty] = {
    return fetchContainer().api_tempChanged
  }

  def get_api_currentTemp(): TempControlMixedSeL4CAmKES.Temperature = {
    return fetchContainer().api_currentTemp
  }
}