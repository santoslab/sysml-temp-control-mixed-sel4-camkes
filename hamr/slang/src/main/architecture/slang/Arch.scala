// #Sireum

package slang

import org.sireum._
import art._
import art.PortMode._
import art.DispatchPropertyProtocol._
import art.Art.BridgeId._
import art.Art.PortId._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

object Arch {
  val TempControlSystem_Instance_tsp_ts : slang.TempControlMixedSeL4CAmKES.TempSensor_tsp_ts_Bridge = {
    val currentTemp = Port[TempControlMixedSeL4CAmKES.Temperature] (id = portId"0", name = "TempControlSystem_Instance_tsp_ts_currentTemp", mode = DataOut)
    val tempChanged = Port[art.Empty] (id = portId"1", name = "TempControlSystem_Instance_tsp_ts_tempChanged", mode = EventOut)

    slang.TempControlMixedSeL4CAmKES.TempSensor_tsp_ts_Bridge(
      id = bridgeId"0",
      name = "TempControlSystem_Instance_tsp_ts",
      dispatchProtocol = Periodic(period = 1000),
      dispatchTriggers = None(),

      currentTemp = currentTemp,
      tempChanged = tempChanged
    )
  }
  val TempControlSystem_Instance_tcp_tc : slang.TempControlMixedSeL4CAmKES.TempControl_tcp_tc_Bridge = {
    val currentTemp = Port[TempControlMixedSeL4CAmKES.Temperature] (id = portId"2", name = "TempControlSystem_Instance_tcp_tc_currentTemp", mode = DataIn)
    val tempChanged = Port[art.Empty] (id = portId"3", name = "TempControlSystem_Instance_tcp_tc_tempChanged", mode = EventIn)
    val fanAck = Port[TempControlMixedSeL4CAmKES.FanAck.Type] (id = portId"4", name = "TempControlSystem_Instance_tcp_tc_fanAck", mode = EventIn)
    val setPoint = Port[TempControlMixedSeL4CAmKES.SetPoint] (id = portId"5", name = "TempControlSystem_Instance_tcp_tc_setPoint", mode = EventIn)
    val fanCmd = Port[TempControlMixedSeL4CAmKES.FanCmd.Type] (id = portId"6", name = "TempControlSystem_Instance_tcp_tc_fanCmd", mode = EventOut)

    slang.TempControlMixedSeL4CAmKES.TempControl_tcp_tc_Bridge(
      id = bridgeId"1",
      name = "TempControlSystem_Instance_tcp_tc",
      dispatchProtocol = Sporadic(min = 1000),
      dispatchTriggers = None(),

      currentTemp = currentTemp,
      tempChanged = tempChanged,
      fanAck = fanAck,
      setPoint = setPoint,
      fanCmd = fanCmd
    )
  }
  val TempControlSystem_Instance_fp_f : slang.TempControlMixedSeL4CAmKES.Fan_fp_f_Bridge = {
    val fanCmd = Port[TempControlMixedSeL4CAmKES.FanCmd.Type] (id = portId"7", name = "TempControlSystem_Instance_fp_f_fanCmd", mode = EventIn)
    val fanAck = Port[TempControlMixedSeL4CAmKES.FanAck.Type] (id = portId"8", name = "TempControlSystem_Instance_fp_f_fanAck", mode = EventOut)

    slang.TempControlMixedSeL4CAmKES.Fan_fp_f_Bridge(
      id = bridgeId"2",
      name = "TempControlSystem_Instance_fp_f",
      dispatchProtocol = Periodic(period = 1000),
      dispatchTriggers = None(),

      fanCmd = fanCmd,
      fanAck = fanAck
    )
  }

  val ad : ArchitectureDescription = {

    ArchitectureDescription(
      components = IS[Art.BridgeId, Bridge] (TempControlSystem_Instance_tsp_ts, TempControlSystem_Instance_tcp_tc, TempControlSystem_Instance_fp_f),

      connections = IS[Art.ConnectionId, UConnection] (Connection(from = TempControlSystem_Instance_tsp_ts.currentTemp, to = TempControlSystem_Instance_tcp_tc.currentTemp),
                                                       Connection(from = TempControlSystem_Instance_tsp_ts.tempChanged, to = TempControlSystem_Instance_tcp_tc.tempChanged),
                                                       Connection(from = TempControlSystem_Instance_tcp_tc.fanCmd, to = TempControlSystem_Instance_fp_f.fanCmd),
                                                       Connection(from = TempControlSystem_Instance_fp_f.fanAck, to = TempControlSystem_Instance_tcp_tc.fanAck))
    )
  }
}
